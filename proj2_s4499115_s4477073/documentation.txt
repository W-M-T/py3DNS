pyDNS: a simple DNS server and resolver

INTRODUCTION:

pyDNS is a simple DNS server and resolver written in Python 2.7 for Linux operating systems.
It is built on top of a provided framework. This framework was written in Python 2.7,
therefore we chose to continue writing code in Python 2.7. Some tests are
provided in dns_tests.py.


RUNNING AND OPTIONS:

The server and tests can be run from command line with several optional parameters.

#running the dns server
python dns_server.py [-c] [-p PORT] [-t time]
#running the tests
python dns_tests.py [-s IP] [-p PORT]
Where:
   c enables caching. Default: disabled.
   p is the port number at which the name server listens. Default: 53.
   t sets the ttl that is applied to all c
   s is the IP address in string format of the name server.


CONNECTION HANDLING:

The server listens for new connections in the main thread. When data is received, a seperate thread is made to handle that data.
In this new thread, the connectionhandler first checks if the query is about the zone that the server is authorative over.
If so, the query is answered directly. Otherwise the request is passed on to a resolver that solves the query recursively.


RESOLVER:

In the beginning, the resolver only knows about the root servers. (There is a flag, use_rs, that disables this for tests).
Additional nameservers can also be passed, but by default this is not the case.
The resolver maintains a stack-like structure of nameservers that it can query.
While we don't have an answer, we pop the most recently added server from that stack and send it the query.
We do not request recursion.
When we get a response that contains an IP for the hostname or one of its aliases, we return the hostname and aliases along
with the IP address(es).


CACHING:

The resolver is capable of using and managing a cache.
If the cache is enabled the resolver first tries to answer the query using the entries in the cache.
If this fails it proceeds performing the steps described above, but in addition, all received responses are stored in the cache.

The cache can be written to a be read from human-readable JSON.


TRANSACTION IDS:

When a transaction ID needs to be generated we pick a random number between 0 and 2^16 - 1.
This number becomes the transaction ID.


CONCURRENCY:

To enable pyDNS to safely use concurrency we had to make minor adjustments.
Multiple records being added to the cache simultaneously could be troublesome. Therefore we make use of a lock that allows
only one record to be added at a time.

Also, even though we only use UDP, sockets are not thread safe. We solved this only allowing one thread to send through the
socket at a time, also making use of a lock.


CHALLENGES:

We have encountered a wide range of problems regarding the framework and have not been able to solve all of them.
We suspect that one problem in the from_bytes function for CNAME records is the cause of our server behaving incorrectly
in some use cases.
We verified that the server retrieves the correct data from the zone file, but after we convert the message to bytes,
send it to the client and then turn it back into a message, the contained data has changed. The lookup fails because of this.

Unexpectedly, Ward was unable to work on the project for the most part of the week before the deadline because one of his
family members passed away. This caused a lot of work to be pushed back until the last two days.

We also had to deal with constant changes to the framework because it was buggy.


LIBRARIES USED:

The following libraries have been used:
    * unittest      for the tests
    * json          for storing and loading the cache
    * struct        for conversion between binary and other types
    * re            for paring the zone file and checking validity of hostnames

In addition, the following (quite) standard libraries have been used:
    * argsparse:    for parsing command line arguments
    * time:         for managing the ttl of cache entries
    * sys:          for passing extra arguments to unittest
    * theading:     for handling each connection on its own thread and for mutex
    * socket:       for networking